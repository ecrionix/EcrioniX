<!DOCTYPE html>
<html lang="en">
<head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6672302762343789"
     crossorigin="anonymous"></script>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-XXZS8C1FLY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-XXZS8C1FLY');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LFSR Lab - EcrioniX</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&family=Orbitron:wght@500;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <!-- MathJax -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body { font-family: 'Outfit', sans-serif; background-color: #020617; color: #f8fafc; }
        .tech-font { font-family: 'Orbitron', sans-serif; }
        .mono-font { font-family: 'JetBrains Mono', monospace; }

        /* Prevent body scroll on desktop */
        @media (min-width: 1024px) { body { overflow: hidden; } }

        .watermark {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-30deg);
            font-size: 8rem; font-weight: 900; color: rgba(99, 102, 241, 0.03);
            pointer-events: none; user-select: none; z-index: 0;
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.7); backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 20px;
        }

        /* Tabs */
        .tab-btn {
            @apply px-3 py-2 text-[10px] md:text-xs font-bold rounded-lg transition-all border border-transparent text-slate-400 uppercase tracking-wider;
        }
        .tab-active {
            @apply bg-indigo-600 text-white border-indigo-500 shadow-lg shadow-indigo-500/30;
        }

        /* LFSR Visuals */
        .ff-box {
            width: 40px; height: 60px;
            background: #1e293b; border: 2px solid #475569;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            position: relative; transition: all 0.2s;
            cursor: pointer;
        }
        .ff-box.tap-active { border-color: #facc15; box-shadow: 0 0 10px rgba(250, 204, 21, 0.3); }
        .ff-val { font-family: 'Orbitron'; font-size: 16px; font-weight: bold; color: white; }
        .ff-label { font-size: 8px; color: #94a3b8; margin-top: 2px; }

        .wire { stroke: #475569; stroke-width: 2; fill: none; transition: stroke 0.2s; }
        .wire-active { stroke: #facc15; filter: drop-shadow(0 0 2px #facc15); }
        
        .xor-gate { fill: #1e293b; stroke: #cbd5e1; stroke-width: 1.5; }

        /* Custom Scroll */
        .custom-scroll { overflow-y: auto; -webkit-overflow-scrolling: touch; }
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #334155; border-radius: 10px; }
        
        input[type=range] { accent-color: #6366f1; height: 0.5rem; cursor: pointer; }

        /* Theory Styles */
        .prose h1 { @apply text-2xl md:text-3xl font-bold text-white mb-6 tech-font border-b border-slate-800 pb-2; }
        .prose h2 { @apply text-lg md:text-xl font-bold text-indigo-400 mt-8 mb-4 uppercase tracking-wider; }
        .prose p { @apply text-slate-400 mb-4 leading-relaxed text-sm md:text-base; }
        .prose strong { @apply text-white font-semibold; }
        .prose ul { @apply list-disc list-inside space-y-2 text-slate-400 mb-4 text-sm md:text-base; }
        
        .hidden { display: none !important; }
    </style>
</head>
<body class="h-screen w-screen flex flex-col relative overflow-hidden">

    <div class="watermark">EcrioniX Logic</div>

    <!-- Header -->
    <nav class="border-b border-slate-800 bg-slate-900/80 px-4 md:px-6 py-3 md:py-4 flex justify-between items-center z-50 flex-shrink-0">
        <div>
            <h1 class="text-xl md:text-2xl font-bold text-indigo-400 tech-font uppercase">LFSR <span class="text-white">LAB</span></h1>
            <p class="text-[9px] md:text-[10px] text-slate-500 uppercase tracking-widest font-bold hidden md:block">Linear Feedback Shift Register</p>
        </div>
        
        <div class="flex bg-slate-950 p-1 rounded-xl border border-slate-800">
            <button onclick="switchView('theory')" id="btn-theory" class="tab-btn tab-active">Theory</button>
            <button onclick="switchView('lab')" id="btn-lab" class="tab-btn">Simulation</button>
        </div>

        <button onclick="window.history.back()" class="group flex items-center text-slate-400 hover:text-white transition bg-slate-800/80 px-3 py-2 rounded-lg border border-slate-700 hover:border-indigo-500 ml-2">
            <span class="text-xs font-bold uppercase hidden md:inline">Exit Lab</span>
            <span class="text-xs font-bold uppercase md:hidden">Exit</span>
        </button>
    </nav>

    <!-- Content -->
    <div class="flex-grow relative overflow-y-auto lg:overflow-hidden">

        <!-- THEORY VIEW -->
        <div id="view-theory" class="absolute inset-0 z-10 overflow-y-auto custom-scroll p-4 md:p-8 flex justify-center">
            <div class="max-w-4xl w-full glass-panel p-6 md:p-10 prose mb-10">
                <h1>The Mathematics of Pseudo-Randomness</h1>
                <p>
                    A **Linear Feedback Shift Register (LFSR)** is a shift register whose input bit is a linear function of its previous state. The most common linear function used is the **Exclusive-OR (XOR)** operation. LFSRs are ubiquitous in digital systems due to their ability to generate pseudo-random sequences, high-speed counters, and error detection codes with minimal hardware.
                </p>

                <h2>1. Core Architecture</h2>
                <p>
                    An LFSR consists of a chain of Flip-Flops (the register) and a feedback network.
                </p>
                <ul>
                    <li><strong>Shift Register:</strong> Shifts bits from one stage to the next on every clock cycle.</li>
                    <li><strong>Taps:</strong> Specific outputs from the register chain that are selected for feedback.</li>
                    <li><strong>Feedback Function:</strong> The selected taps are XORed together to calculate the new input bit (MSB or LSB depending on architecture).</li>
                </ul>

                <h2>2. Fibonacci vs. Galois Implementation</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 my-4">
                    <div class="bg-slate-900/50 p-4 rounded border border-slate-700">
                        <h3 class="text-white font-bold text-sm mb-2">Fibonacci (Many-to-One)</h3>
                        <p class="text-xs text-slate-400">
                            The standard form. The outputs of the tapped flip-flops are all XORed together in a single logic cloud, and the result is fed back to the <strong>input</strong> of the first flip-flop.
                            <br><br>
                            <em>Downside:</em> As the number of bits grows, the logic depth of the XOR chain increases, limiting the maximum clock frequency (propagation delay).
                        </p>
                    </div>
                    <div class="bg-slate-900/50 p-4 rounded border border-slate-700">
                        <h3 class="text-white font-bold text-sm mb-2">Galois (One-to-Many)</h3>
                        <p class="text-xs text-slate-400">
                            The output of the last flip-flop is fed back to the input of the first, but it is also XORed into specific intermediate stages along the chain.
                            <br><br>
                            <em>Upside:</em> The XOR gates are placed between flip-flops. This breaks the critical path, allowing each stage to resolve in parallel. It is preferred for high-speed hardware.
                        </p>
                    </div>
                </div>

                <h2>3. Maximal Length Sequences</h2>
                <p>
                    An LFSR with $n$ bits has $2^n$ possible states. However, the state of all zeros is a "lock-up" state (0 XOR 0 = 0, so it never changes). Therefore, the maximum number of unique states an LFSR can cycle through is **$2^n - 1$**.
                </p>
                <p>
                    To achieve this maximum length, the feedback taps must correspond to a **Primitive Polynomial** over the Galois field GF(2). If the taps are chosen incorrectly, the sequence will repeat much sooner, creating a shorter cycle.
                </p>

                <h2>4. Applications in VLSI & Systems</h2>
                <ul>
                    <li><strong>BIST (Built-In Self-Test):</strong> Used to generate random test patterns to check internal logic gates for faults.</li>
                    <li><strong>CRC (Cyclic Redundancy Check):</strong> Used in Ethernet, USB, and storage to detect data corruption during transmission.</li>
                    <li><strong>Scrambling/Whitening:</strong> Used in PCIe and WiFi to randomize data patterns, reducing electromagnetic interference (EMI) and preventing resonant frequency spikes.</li>
                    <li><strong>Cryptography:</strong> Stream ciphers (like A5/1 used in GSM) utilize LFSRs, though modern crypto requires non-linear elements for security.</li>
                </ul>

                <div class="mt-8 text-center pb-8">
                    <button onclick="switchView('lab')" class="bg-indigo-600 hover:bg-indigo-500 text-white px-8 py-3 rounded-xl font-bold transition shadow-lg shadow-indigo-500/20">Launch Simulator &rarr;</button>
                </div>
            </div>
        </div>

        <!-- LAB VIEW -->
        <div id="view-lab" class="absolute inset-0 z-0 opacity-0 pointer-events-none flex flex-col lg:flex-row p-4 lg:p-6 gap-6 overflow-y-auto custom-scroll">
            
            <!-- Left: Controls -->
            <div class="w-full lg:w-80 flex flex-col gap-4 flex-shrink-0">
                <div class="glass-panel p-6">
                    <h2 class="text-indigo-400 font-bold mb-4 uppercase text-[10px] tracking-widest">Configuration</h2>
                    
                    <div class="space-y-6">
                        <!-- Bits -->
                        <div>
                            <div class="flex justify-between text-xs mb-2">
                                <span class="text-slate-300">Register Width (N)</span>
                                <span id="val-n" class="font-mono text-white font-bold">4 Bits</span>
                            </div>
                            <input type="range" id="slider-n" min="3" max="8" step="1" value="4" class="w-full">
                        </div>

                        <!-- Architecture -->
                        <div>
                            <span class="text-xs text-slate-300 font-bold block mb-2">Architecture</span>
                            <div class="flex bg-slate-900 p-1 rounded-lg">
                                <button onclick="setArch('FIB')" id="btn-fib" class="flex-1 py-2 rounded text-[10px] font-bold bg-indigo-600 text-white shadow">FIBONACCI</button>
                                <button onclick="setArch('GAL')" id="btn-gal" class="flex-1 py-2 rounded text-[10px] font-bold bg-slate-800 text-slate-400 hover:text-white">GALOIS</button>
                            </div>
                        </div>

                        <!-- Initial Seed -->
                        <div>
                            <div class="flex justify-between text-xs mb-2">
                                <span class="text-slate-300">Seed Value (Hex)</span>
                                <input type="text" id="inp-seed" value="1" class="w-12 bg-slate-800 border border-slate-700 rounded text-center text-white font-mono text-xs focus:border-indigo-500 outline-none" maxlength="2">
                            </div>
                            <button onclick="resetLab()" class="w-full py-2 bg-slate-800 border border-slate-600 rounded text-xs text-slate-300 hover:text-white">LOAD SEED</button>
                        </div>

                        <div class="pt-4 border-t border-slate-700">
                             <div class="flex gap-2">
                                <button onclick="step()" class="flex-1 py-3 bg-indigo-600 hover:bg-indigo-500 text-white font-bold rounded shadow-lg active:scale-95 text-xs">STEP CLOCK</button>
                                <button onclick="toggleAuto()" id="btn-auto" class="flex-1 py-3 bg-slate-700 hover:bg-slate-600 text-white font-bold rounded shadow active:scale-95 text-xs">AUTO RUN</button>
                             </div>
                        </div>
                    </div>
                </div>

                <!-- Analysis -->
                <div class="glass-panel p-6 flex-grow">
                    <h2 class="text-emerald-400 font-bold mb-4 uppercase text-[10px] tracking-widest">Sequence Analysis</h2>
                    <div class="space-y-3">
                        <div class="bg-black/40 p-3 rounded border border-slate-800 flex justify-between items-center">
                            <span class="text-xs text-slate-400">Current Value</span>
                            <span id="stat-val" class="text-white font-mono font-bold text-lg">0x1</span>
                        </div>
                        <div class="bg-black/40 p-3 rounded border border-slate-800 flex justify-between items-center">
                            <span class="text-xs text-slate-400">Period Counter</span>
                            <span id="stat-count" class="text-indigo-400 font-mono font-bold">0</span>
                        </div>
                        <div class="bg-black/40 p-3 rounded border border-slate-800 flex justify-between items-center">
                            <span class="text-xs text-slate-400">Max Period ($2^n-1$)</span>
                            <span id="stat-max" class="text-slate-500 font-mono font-bold">15</span>
                        </div>
                        <div id="cycle-alert" class="hidden mt-2 p-2 bg-green-900/30 border border-green-500/50 rounded text-center text-[10px] text-green-400 font-bold">
                            SEQUENCE REPEATED!
                        </div>
                    </div>
                    
                    <div class="mt-4 h-32 overflow-y-auto bg-black/20 rounded border border-slate-800 p-2 font-mono text-[10px] text-slate-400" id="history-log">
                        <!-- History -->
                    </div>
                </div>
            </div>

            <!-- Right: Visualization -->
            <div class="flex-grow flex flex-col gap-6 min-h-[400px] lg:min-h-0">
                <div class="glass-panel p-1 relative flex-grow overflow-hidden flex flex-col">
                    <div class="absolute top-4 left-4 z-10 px-3 py-1 bg-black/60 rounded text-[10px] text-slate-400 border border-slate-700 font-bold uppercase tracking-widest">
                        Circuit View <span class="text-slate-600 normal-case ml-2">(Click FFs to Toggle Taps)</span>
                    </div>
                    
                    <!-- SVG Container -->
                    <div class="w-full h-full bg-slate-900/50 flex items-center justify-center relative overflow-x-auto" id="circuit-container">
                         <!-- SVG Injected Here -->
                         <svg id="svg-circuit" width="100%" height="100%"></svg>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- State ---
        let nBits = 4;
        let arch = 'FIB'; // FIB or GAL
        let reg = 1; // Integer representation of register
        let taps = [3, 2]; // Default taps for 4-bit (Indices 0 to n-1)
        
        // Simulation
        let initialSeed = 1;
        let periodCount = 0;
        let history = [];
        let isAuto = false;
        let autoInterval = null;
        let cycleFound = false;

        // Default Primitive Polynomials (for auto-suggestion if needed, but we let user play)
        // 3: [2, 1]
        // 4: [3, 2]
        // 5: [4, 2]
        // 6: [5, 4]
        // 7: [6, 5]
        // 8: [7, 5, 4, 3]

        // --- DOM ---
        const svg = document.getElementById('svg-circuit');
        const sliderN = document.getElementById('slider-n');
        const inpSeed = document.getElementById('inp-seed');
        const logBox = document.getElementById('history-log');
        
        // --- Initialization ---
        function switchView(v) {
            const theory = document.getElementById('view-theory');
            const lab = document.getElementById('view-lab');
            const btnT = document.getElementById('btn-theory');
            const btnL = document.getElementById('btn-lab');

            if (v === 'theory') {
                theory.classList.remove('opacity-0', 'pointer-events-none'); theory.classList.add('z-10');
                lab.classList.add('opacity-0', 'pointer-events-none'); lab.classList.remove('z-10');
                btnT.classList.add('tab-active'); btnL.classList.remove('tab-active');
            } else {
                lab.classList.remove('opacity-0', 'pointer-events-none'); lab.classList.add('z-10');
                theory.classList.add('opacity-0', 'pointer-events-none'); theory.classList.remove('z-10');
                btnL.classList.add('tab-active'); btnT.classList.remove('tab-active');
                drawCircuit();
            }
        }

        function setArch(a) {
            arch = a;
            document.getElementById('btn-fib').className = a==='FIB' ? "flex-1 py-2 rounded text-[10px] font-bold bg-indigo-600 text-white shadow" : "flex-1 py-2 rounded text-[10px] font-bold bg-slate-800 text-slate-400 hover:text-white";
            document.getElementById('btn-gal').className = a==='GAL' ? "flex-1 py-2 rounded text-[10px] font-bold bg-indigo-600 text-white shadow" : "flex-1 py-2 rounded text-[10px] font-bold bg-slate-800 text-slate-400 hover:text-white";
            resetLab();
        }

        sliderN.addEventListener('input', (e) => {
            nBits = parseInt(e.target.value);
            document.getElementById('val-n').innerText = nBits + " Bits";
            document.getElementById('stat-max').innerText = Math.pow(2, nBits) - 1;
            // Reset taps to just MSB and MSB-1 for simplicity
            taps = [nBits-1, nBits-2];
            resetLab();
        });

        function resetLab() {
            stopAuto();
            const seedVal = parseInt(inpSeed.value, 16);
            if (isNaN(seedVal) || seedVal === 0) {
                alert("Seed cannot be 0 or invalid.");
                reg = 1;
                inpSeed.value = "1";
            } else {
                reg = seedVal & ((1 << nBits) - 1); // Mask
            }
            initialSeed = reg;
            
            periodCount = 0;
            history = [];
            cycleFound = false;
            document.getElementById('cycle-alert').classList.add('hidden');
            logBox.innerHTML = `<div class="text-indigo-400">Seed Loaded: 0x${reg.toString(16).toUpperCase()}</div>`;
            
            updateStats();
            drawCircuit();
        }

        function toggleTap(idx) {
            // Cannot toggle MSB tap in Fibonacci usually (it's the feedback source), 
            // but let's allow flexibility. 
            // If exists, remove. If not, add.
            const i = taps.indexOf(idx);
            if (i > -1) taps.splice(i, 1);
            else taps.push(idx);
            drawCircuit();
        }

        // --- Circuit Drawing ---
        function drawCircuit() {
            // Calculate dimensions
            const ffWidth = 60;
            const ffGap = 40;
            const startX = 50;
            const startY = 150;
            
            // Rebuild SVG
            let html = `<defs>
                <marker id="arrow" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto"><path d="M0,0 L0,6 L6,3 z" fill="#475569" /></marker>
            </defs>`;

            // Draw FFs (Order: MSB on Left? Usually LSB on right. Let's do Q(n-1)...Q0 left to right)
            // Array index 0 is LSB. 
            // So visual Left is index n-1. Visual Right is index 0.
            
            for(let i=nBits-1; i>=0; i--) {
                const x = startX + (nBits-1-i) * (ffWidth + ffGap);
                const bitVal = (reg >> i) & 1;
                const isTapped = taps.includes(i);
                
                // FF Box
                const activeClass = isTapped ? "ff-box tap-active" : "ff-box";
                const strokeColor = isTapped ? "#facc15" : "#475569";
                
                // We use foreignObject or simulated rects for click events
                // Using group with onclick
                html += `<g onclick="toggleTap(${i})" cursor="pointer">
                    <rect x="${x}" y="${startY}" width="${ffWidth}" height="80" rx="4" fill="#1e293b" stroke="${strokeColor}" stroke-width="2" class="${isTapped ? 'shadow' : ''}"/>
                    <text x="${x+30}" y="${startY+45}" text-anchor="middle" class="ff-val">${bitVal}</text>
                    <text x="${x+30}" y="${startY+15}" text-anchor="middle" class="ff-label">Q${i}</text>
                </g>`;
                
                // Connecting Wires (Q to D)
                if (i > 0) {
                    const nextX = x + ffWidth;
                    // Standard connection
                    let wireColor = "#475569";
                    
                    if (arch === 'GAL' && isTapped && i !== nBits-1) {
                         // XOR Gate insertion visually
                         html += `<circle cx="${nextX + ffGap/2}" cy="${startY+40}" r="8" stroke="#cbd5e1" fill="#1e293b" stroke-width="2"/>`;
                         html += `<line x1="${nextX + ffGap/2}" y1="${startY+32}" x2="${nextX + ffGap/2}" y2="${startY+48}" stroke="#cbd5e1" stroke-width="2"/>`;
                         html += `<line x1="${nextX + ffGap/2 - 8}" y1="${startY+40}" x2="${nextX + ffGap/2 + 8}" y2="${startY+40}" stroke="#cbd5e1" stroke-width="2"/>`;
                         // Feedback line coming down
                         html += `<line x1="${nextX + ffGap/2}" y1="${startY-40}" x2="${nextX + ffGap/2}" y2="${startY+32}" class="wire ${bitVal?'wire-active':''}" />`;
                    } else {
                         html += `<line x1="${nextX}" y1="${startY+40}" x2="${nextX + ffGap}" y2="${startY+40}" class="wire" marker-end="url(#arrow)"/>`;
                    }
                }
            }

            // Feedback Path
            // Visual line from tapped bits to feedback logic
            let fbPath = "";
            const totalW = nBits * ffWidth + (nBits-1) * ffGap;
            
            if (arch === 'FIB') {
                // Fibonacci: Taps go to XOR tree on top, then to input of MSB (Leftmost)
                // Draw line up from each tapped FF
                let tapPoints = [];
                for(let t of taps) {
                    const tx = startX + (nBits-1-t) * (ffWidth + ffGap) + ffWidth/2;
                    html += `<line x1="${tx}" y1="${startY}" x2="${tx}" y2="${startY-40}" class="wire wire-active" />`;
                    tapPoints.push(tx);
                }
                
                // Horizontal Bus on top
                const minX = Math.min(...tapPoints, startX);
                const maxX = Math.max(...tapPoints);
                html += `<line x1="${minX}" y1="${startY-40}" x2="${maxX}" y2="${startY-40}" class="wire wire-active" />`;
                
                // XOR Symbol at input (Left)
                html += `<circle cx="${startX - 20}" cy="${startY+40}" r="10" stroke="#cbd5e1" fill="#1e293b"/>`; // XOR
                html += `<line x1="${startX}" y1="${startY-40}" x2="${startX-20}" y2="${startY-40}" class="wire wire-active" />`; // Top to XOR
                html += `<line x1="${startX-20}" y1="${startY-40}" x2="${startX-20}" y2="${startY+30}" class="wire wire-active" />`; 
                html += `<line x1="${startX-10}" y1="${startY+40}" x2="${startX}" y2="${startY+40}" class="wire" marker-end="url(#arrow)"/>`; // XOR to In
            } 
            else {
                // Galois: Output LSB (Rightmost, index 0) feeds back to Input MSB and Taps
                const lsbX = startX + totalW - ffWidth/2;
                const feedbackY = startY - 40;
                
                // Line from LSB up and back left
                html += `<polyline points="${lsbX},${startY+80} ${lsbX},${startY+100} ${startX-20},${startY+100} ${startX-20},${startY+40} ${startX},${startY+40}" class="wire wire-active" fill="none" marker-end="url(#arrow)"/>`;
                
                // Taps connection
                for(let t of taps) {
                    // For Galois, tap means XOR is placed BEFORE index t. 
                    // Input to FF[t] = Q[t+1] XOR Q[0].
                    // Visual position is between t+1 and t.
                    if (t === nBits-1) continue; // MSB input already handled by main loop line
                    
                    const tx = startX + (nBits-1-t) * (ffWidth + ffGap) - ffGap/2; // Between blocks
                    html += `<line x1="${tx}" y1="${startY+100}" x2="${tx}" y2="${startY+50}" class="wire wire-active" />`;
                }
            }

            svg.innerHTML = html;
        }

        // --- Simulation Logic ---
        function step() {
            if (cycleFound) return;
            
            periodCount++;
            
            let feedback = 0;
            const lsb = reg & 1;
            const msb = (reg >> (nBits-1)) & 1;

            if (arch === 'FIB') {
                // Fibonacci: Feedback = XOR sum of tapped bits
                // Next state: Shift Left (reg << 1) | Feedback
                // Note: Standard LFSR usually shifts RIGHT (MSB -> LSB).
                // Let's assume Shift Right: Q0 is output. Input goes into MSB.
                // Input = XOR(Taps).
                
                taps.forEach(t => {
                    if ((reg >> t) & 1) feedback ^= 1;
                });
                
                // Shift Right
                reg = (reg >> 1) | (feedback << (nBits - 1));
            } 
            else {
                // Galois: Shift Right. If LSB was 1, toggle bits at taps.
                // Output bit
                const outBit = reg & 1;
                reg = reg >> 1;
                if (outBit) {
                    taps.forEach(t => {
                        // Toggle bit at position t (MSB is n-1)
                        // In Galois, standard is usually taps apply XOR.
                        // Polynomial x^n + x^a + 1.
                        // Here, we just XOR the register with a mask if LSB is 1.
                        // Mask has 1s at tap positions.
                        reg ^= (1 << (t)); // Toggle specific bit (except MSB which is fed by LSB)
                        // MSB feed is handled by shift usually (Input MSB = LSB).
                        reg |= (1 << (nBits-1)); // MSB gets LSB (since shifted 0, make it 1)
                        // Wait, pure Galois:
                        // if lsb=0: shift right.
                        // if lsb=1: shift right AND XOR with poly.
                        // My logic above: shift right first. The MSB becomes 0.
                        // If we XOR with mask containing MSB tap, it sets MSB.
                        // Let's stick to standard code:
                    });
                     // Re-do Galois standard
                     // Only works if taps defines the mask
                     // Mask: sum(1<<t)
                }
                
                // Let's implement simpler standard Galois
                // Tap indices usually correspond to exponents.
                // Let's use the user's selected taps as the XOR mask.
                // But we must handle the MSB feed.
                // Standard: new_bit = reg & 1. reg >>= 1. if(new_bit) reg ^= mask.
                // Mask typically includes MSB tap.
                
                // Re-calculate for this lab:
                // User selects active taps visually.
                let mask = 0;
                taps.forEach(t => mask |= (1 << t));
                
                let dropBit = lsb;
                reg = reg >> 1;
                if (dropBit) {
                    reg ^= mask;
                    // For Galois to work as ring, the MSB usually is implicitly tapped or fed.
                    // The standard algorithm: if (lsb) reg ^= poly_mask. 
                    // Poly mask usually has MSB bit set.
                    // I'll ensure MSB is part of feedback loop visually by drawing line to input.
                    // In code, if MSB tap is NOT selected in UI, it won't feedback? 
                    // That breaks LFSR.
                    // Let's assume MSB always feeds back in Galois.
                    reg |= (1 << (nBits - 1)); // Feedback to MSB
                }
            }

            // Check Cycle
            if (reg === initialSeed && periodCount > 0) {
                cycleFound = true;
                stopAuto();
                document.getElementById('cycle-alert').classList.remove('hidden');
                addLog(`Cycle Detected! Period: ${periodCount}`);
            } else {
                addLog(`State: 0x${reg.toString(16).toUpperCase()}`);
            }

            updateStats();
            drawCircuit();
        }

        function updateStats() {
            document.getElementById('stat-val').innerText = "0x" + reg.toString(16).toUpperCase();
            document.getElementById('stat-count').innerText = periodCount;
        }

        function addLog(msg) {
            const div = document.createElement('div');
            div.innerText = msg;
            logBox.prepend(div);
            if (logBox.children.length > 50) logBox.lastChild.remove();
        }

        function toggleAuto() {
            if (isAuto) stopAuto();
            else {
                if (cycleFound) resetLab(); // Auto restart
                isAuto = true;
                document.getElementById('btn-auto').classList.replace('bg-slate-700', 'bg-red-600');
                document.getElementById('btn-auto').innerText = "STOP";
                autoInterval = setInterval(step, 100); // 10Hz
            }
        }

        function stopAuto() {
            isAuto = false;
            clearInterval(autoInterval);
            document.getElementById('btn-auto').classList.replace('bg-red-600', 'bg-slate-700');
            document.getElementById('btn-auto').innerText = "AUTO RUN";
        }

        // Init
        switchView('theory');

    </script>
</body>
</html>
