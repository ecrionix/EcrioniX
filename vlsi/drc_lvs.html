<!DOCTYPE html>
<html lang="en">
<head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6672302762343789"
     crossorigin="anonymous"></script>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-XXZS8C1FLY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-XXZS8C1FLY');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Layout DRC & LVS Lab - EcrioniX</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&family=Orbitron:wght@500;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Outfit', sans-serif; background-color: #020617; color: #f8fafc; overflow: hidden; }
        .tech-font { font-family: 'Orbitron', sans-serif; }
        .mono-font { font-family: 'JetBrains Mono', monospace; }

        /* Watermark */
        .watermark {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-30deg);
            font-size: 8rem; font-weight: 900; color: rgba(99, 102, 241, 0.03);
            pointer-events: none; user-select: none; z-index: 0;
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.7); backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 16px;
        }

        /* Layout Grid */
        #layout-canvas {
            background-color: #000;
            background-image: 
                linear-gradient(rgba(50, 50, 50, 0.5) 1px, transparent 1px),
                linear-gradient(90deg, rgba(50, 50, 50, 0.5) 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: crosshair;
        }

        /* Layer Buttons */
        .layer-btn { @apply px-3 py-2 rounded text-xs font-bold border transition-all; }
        .layer-active { transform: scale(1.05); box-shadow: 0 0 10px currentColor; }
        
        .layer-metal { border-color: #3b82f6; color: #3b82f6; }
        .layer-metal.active { background: #3b82f6; color: white; }
        
        .layer-poly { border-color: #ef4444; color: #ef4444; }
        .layer-poly.active { background: #ef4444; color: white; }
        
        .layer-diff { border-color: #22c55e; color: #22c55e; }
        .layer-diff.active { background: #22c55e; color: white; }

        /* Tabs */
        .tab-btn {
            @apply px-4 py-2 text-xs font-bold rounded-lg transition-all border border-transparent text-slate-400 uppercase tracking-wider;
        }
        .tab-active {
            @apply bg-indigo-600 text-white border-indigo-500 shadow-lg shadow-indigo-500/30;
        }

        /* Error Markers */
        .drc-error {
            animation: pulse-error 1s infinite;
            stroke: #ff0000;
            stroke-width: 2;
            fill: rgba(255, 0, 0, 0.2);
        }
        @keyframes pulse-error { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

        input[type=range] { accent-color: #6366f1; }
    </style>
</head>
<body class="h-screen w-screen flex flex-col relative">

    <div class="watermark">EcrioniX VLSI</div>

    <!-- Header -->
    <nav class="border-b border-slate-800 bg-slate-900/80 px-6 py-4 flex justify-between items-center z-20">
        <div>
            <h1 class="text-2xl font-bold text-indigo-400 tech-font uppercase">LAYOUT <span class="text-white">DESIGN</span></h1>
            <p class="text-[10px] text-slate-500 uppercase tracking-widest font-bold">Physical Verification: DRC & LVS</p>
        </div>
        
        <div class="flex bg-slate-950 p-1 rounded-xl border border-slate-800">
            <button onclick="switchView('theory')" id="btn-theory" class="tab-btn">THEORY</button>
            <button onclick="switchView('drc')" id="btn-drc" class="tab-btn tab-active">DRC LAB</button>
            <button onclick="switchView('lvs')" id="btn-lvs" class="tab-btn">LVS LAB</button>
        </div>

        <button onclick="window.history.back()" class="group flex items-center text-slate-400 hover:text-white transition bg-slate-800/80 px-4 py-2 rounded-lg border border-slate-700 hover:border-indigo-500">
            <span class="text-xs font-bold uppercase">Exit Lab</span>
        </button>
    </nav>

    <!-- Main Content -->
    <div class="flex-grow flex relative overflow-hidden">

        <!-- THEORY VIEW -->
        <div id="view-theory" class="absolute inset-0 z-0 opacity-0 pointer-events-none p-8 overflow-y-auto flex justify-center bg-[#020617]">
            <div class="max-w-4xl w-full glass-panel p-10 prose text-slate-300">
                <h1 class="text-3xl font-bold text-white mb-6 tech-font border-b border-slate-800 pb-2">Physical Verification Basics</h1>
                
                <h2 class="text-xl font-bold text-indigo-400 mt-8 mb-4">1. Design Rule Check (DRC)</h2>
                <p class="mb-4">DRC ensures your layout can actually be manufactured. It checks geometric constraints imposed by the foundry's lithography process.</p>
                <ul class="list-disc list-inside space-y-2 mb-6 ml-4">
                    <li><strong>Min Width:</strong> Wires too thin may break during fabrication (Open circuit).</li>
                    <li><strong>Min Spacing:</strong> Wires too close may bridge together (Short circuit).</li>
                    <li><strong>Enclosure:</strong> Vias must be fully covered by metal to ensure good contact.</li>
                </ul>

                <h2 class="text-xl font-bold text-teal-400 mt-8 mb-4">2. Layout Versus Schematic (LVS)</h2>
                <p class="mb-4">LVS verifies that the physical layout corresponds exactly to the electrical schematic (netlist). It extracts devices (transistors, resistors) and connections from the shapes and compares them graph-to-graph.</p>
                <div class="bg-slate-800 p-4 rounded border-l-4 border-teal-500 text-sm">
                    <strong>Common LVS Errors:</strong> Shorted power rails (VDD/GND), open nets, or swapped inputs.
                </div>
            </div>
        </div>

        <!-- DRC LAB VIEW -->
        <div id="view-drc" class="absolute inset-0 z-10 flex p-6 gap-6">
            <!-- Left Controls -->
            <div class="w-72 flex flex-col gap-4">
                <div class="glass-panel p-6">
                    <h2 class="text-indigo-400 font-bold mb-4 text-xs uppercase tracking-widest">Tech Node Config</h2>
                    <div class="space-y-6">
                        <div>
                            <div class="flex justify-between text-xs mb-1 text-slate-300">
                                <span>Process Node</span>
                                <span id="lbl-node" class="font-bold text-white">180 nm</span>
                            </div>
                            <input type="range" id="slider-node" min="0" max="2" step="1" value="0" class="w-full">
                            <div class="flex justify-between text-[9px] text-slate-500 mt-1">
                                <span>180nm</span><span>90nm</span><span>45nm</span>
                            </div>
                        </div>
                        <div class="space-y-2 text-xs font-mono text-slate-400">
                            <div class="flex justify-between"><span>Min Width:</span><span id="rule-width" class="text-white">3 units</span></div>
                            <div class="flex justify-between"><span>Min Space:</span><span id="rule-space" class="text-white">3 units</span></div>
                        </div>
                    </div>
                </div>

                <div class="glass-panel p-6">
                    <h2 class="text-slate-400 font-bold mb-4 text-xs uppercase tracking-widest">Layer Palette</h2>
                    <div class="grid grid-cols-2 gap-3">
                        <button onclick="setLayer('metal')" id="btn-metal" class="layer-btn layer-metal active">METAL 1</button>
                        <button onclick="setLayer('poly')" id="btn-poly" class="layer-btn layer-poly">POLY</button>
                        <button onclick="setLayer('diff')" id="btn-diff" class="layer-btn layer-diff">DIFFUSION</button>
                        <button onclick="clearCanvas()" class="col-span-2 py-2 text-xs font-bold text-slate-400 border border-slate-700 rounded hover:bg-slate-800">CLEAR ALL</button>
                    </div>
                </div>

                <div class="glass-panel p-4 flex-grow bg-slate-900/50 border-red-900/30 border">
                    <h2 class="text-red-400 font-bold mb-2 text-xs uppercase tracking-widest">DRC Violations</h2>
                    <div id="drc-log" class="text-[10px] mono-font text-red-300 space-y-1 overflow-y-auto h-full">
                        <div>> System Ready.</div>
                        <div>> Draw shapes to check rules.</div>
                    </div>
                </div>
            </div>

            <!-- Canvas Area -->
            <div class="flex-grow glass-panel relative p-1 overflow-hidden flex flex-col">
                <div class="absolute top-4 left-4 z-10 bg-black/60 px-3 py-1 rounded text-[10px] text-slate-400 border border-slate-700">
                    Mode: <span id="mode-display" class="text-white font-bold">DRAWING (METAL 1)</span>
                </div>
                <canvas id="layout-canvas" width="800" height="600" class="w-full h-full"></canvas>
            </div>
        </div>

        <!-- LVS LAB VIEW (Simplified) -->
        <div id="view-lvs" class="absolute inset-0 z-0 opacity-0 pointer-events-none flex p-6 gap-6 justify-center items-center">
            <div class="glass-panel p-8 text-center max-w-lg">
                <h1 class="text-2xl text-white font-bold mb-4 tech-font">LVS Challenge</h1>
                <p class="text-slate-400 text-sm mb-6">
                    LVS requires matching a complex netlist graph. <br>
                    <span class="text-indigo-400">Coming Soon:</span> An interactive CMOS Inverter routing challenge.
                </p>
                <button onclick="switchView('drc')" class="px-6 py-2 bg-indigo-600 hover:bg-indigo-500 text-white rounded font-bold transition">Back to DRC</button>
            </div>
        </div>

    </div>

    <script>
        // --- Configuration ---
        const GRID_SIZE = 20;
        const RULES = [
            { name: "180nm", minWidth: 3, minSpace: 3 },
            { name: "90nm", minWidth: 2, minSpace: 2 },
            { name: "45nm", minWidth: 1, minSpace: 1 } // Stricter = smaller tolerance? No, relative grid units. 
            // Actually, in grid units, finer process means you can draw smaller.
            // Let's invert: Rules are minimum Grid Units.
            // 180nm: Coarse. Min Width = 4 blocks.
            // 45nm: Fine. Min Width = 1 block.
        ];
        
        // Correct Logic: 
        // We keep grid fixed.
        // Rule: "Min Width = X blocks".
        // 180nm process implies features are large relative to grid? 
        // Let's say Grid = 10nm. 
        // 180nm => Min Width 18 blocks. Too big.
        // Let's simplify: 
        // Level 1 (Easy/180nm): Min Width = 1 block.
        // Level 2 (Hard/45nm): Min Width = 3 blocks (Simulating that resolving small features is harder/requires double patterning etc? No)
        
        // Standard DRC Logic:
        // Rule is fixed for a technology.
        // Let's stick to: We are validating against "Min Width = 2 grid units".
        
        let currentRule = { minW: 2, minS: 2 }; 

        // --- State ---
        let currentLayer = 'metal'; // metal, poly, diff
        let shapes = []; // {x, y, w, h, layer} (Grid coordinates)
        let isDrawing = false;
        let startX, startY;
        let tempShape = null;

        // --- DOM ---
        const canvas = document.getElementById('layout-canvas');
        const ctx = canvas.getContext('2d');
        const drcLog = document.getElementById('drc-log');
        
        // --- Initialization ---
        function resize() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            draw();
        }
        window.addEventListener('resize', resize);
        setTimeout(resize, 100); // Initial layout

        // --- Drawing Logic ---
        function getGridPos(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / GRID_SIZE);
            const y = Math.floor((e.clientY - rect.top) / GRID_SIZE);
            return {x, y};
        }

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const pos = getGridPos(e);
            startX = pos.x;
            startY = pos.y;
            tempShape = { x: startX, y: startY, w: 1, h: 1, layer: currentLayer };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const pos = getGridPos(e);
            const w = pos.x - startX + (pos.x >= startX ? 1 : 0); // Include current block
            const h = pos.y - startY + (pos.y >= startY ? 1 : 0);
            
            // Normalize negative width/height
            tempShape.x = w > 0 ? startX : pos.x;
            tempShape.y = h > 0 ? startY : pos.y;
            tempShape.w = Math.abs(w);
            tempShape.h = Math.abs(h);
            
            draw();
        });

        canvas.addEventListener('mouseup', () => {
            if (!isDrawing) return;
            isDrawing = false;
            // Add shape if valid size
            if (tempShape.w > 0 && tempShape.h > 0) {
                shapes.push({...tempShape});
            }
            tempShape = null;
            runDRC(); // Check instantly
            draw();
        });

        // --- DRC Engine ---
        function runDRC() {
            let errors = [];
            const rW = currentRule.minW;
            const rS = currentRule.minS;

            shapes.forEach((s, i) => {
                s.error = false; // Reset

                // 1. Width Check
                // Smallest dimension must be >= rW
                const minDim = Math.min(s.w, s.h);
                if (minDim < rW) {
                    s.error = true;
                    errors.push(`Shape ${i}: Width Violation (${minDim} < ${rW})`);
                }

                // 2. Spacing Check (vs same layer)
                for (let j = i + 1; j < shapes.length; j++) {
                    const other = shapes[j];
                    if (s.layer !== other.layer) continue;

                    // Check overlap or proximity
                    // Calculate distance between rectangles
                    const x_overlap = Math.max(0, Math.min(s.x + s.w, other.x + other.w) - Math.max(s.x, other.x));
                    const y_overlap = Math.max(0, Math.min(s.y + s.h, other.y + other.h) - Math.max(s.y, other.y));

                    if (x_overlap > 0 && y_overlap > 0) {
                        // Merged shapes (simplified: treat as valid connection for now)
                        continue; 
                    }

                    // Simple spacing check: Distance between edges
                    const dx = Math.max(0, Math.max(s.x, other.x) - Math.min(s.x + s.w, other.x + other.w));
                    const dy = Math.max(0, Math.max(s.y, other.y) - Math.min(s.y + s.h, other.y + other.h));
                    
                    const dist = Math.max(dx, dy); // Manhattan distance approximation for adjacent
                    
                    if (dist > 0 && dist < rS) {
                        s.error = true;
                        other.error = true;
                        errors.push(`Spacing Violation: Layer ${s.layer} (${dist} < ${rS})`);
                    }
                }
            });

            // Update Log
            drcLog.innerHTML = "";
            if (errors.length === 0) {
                drcLog.innerHTML = "<div class='text-green-400'>DRC CLEAN! No violations found.</div>";
            } else {
                errors.forEach(e => {
                    drcLog.innerHTML += `<div>> ${e}</div>`;
                });
            }
        }

        // --- Render ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw all shapes
            [...shapes, tempShape].forEach(s => {
                if (!s) return;
                
                const px = s.x * GRID_SIZE;
                const py = s.y * GRID_SIZE;
                const pw = s.w * GRID_SIZE;
                const ph = s.h * GRID_SIZE;

                ctx.beginPath();
                ctx.rect(px, py, pw, ph);
                
                // Styles
                if (s.layer === 'metal') {
                    ctx.fillStyle = "rgba(59, 130, 246, 0.5)"; // Blue
                    ctx.strokeStyle = "#3b82f6";
                } else if (s.layer === 'poly') {
                    ctx.fillStyle = "rgba(239, 68, 68, 0.5)"; // Red
                    ctx.strokeStyle = "#ef4444";
                } else {
                    ctx.fillStyle = "rgba(34, 197, 94, 0.5)"; // Green
                    ctx.strokeStyle = "#22c55e";
                }
                
                // Error Highlight
                if (s.error) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = "#ff0000";
                    ctx.strokeStyle = "#ff0000";
                    ctx.lineWidth = 2;
                    ctx.fillStyle = "rgba(255, 0, 0, 0.2)"; // Hatching usually, but solid red tint here
                } else {
                    ctx.shadowBlur = 0;
                    ctx.lineWidth = 1;
                }

                ctx.fill();
                ctx.stroke();
                
                // Hatching for Poly (Visual distinction)
                if (s.layer === 'poly') {
                    ctx.beginPath();
                    for(let i=0; i<pw+ph; i+=10) {
                        ctx.moveTo(px + i, py);
                        ctx.lineTo(px, py + i);
                    }
                    ctx.strokeStyle = "rgba(255,255,255,0.2)";
                    ctx.stroke();
                }
            });
        }

        // --- UI Logic ---
        function setLayer(l) {
            currentLayer = l;
            const name = l === 'metal' ? 'METAL 1' : (l === 'poly' ? 'POLYSILICON' : 'DIFFUSION');
            document.getElementById('mode-display').innerText = `DRAWING (${name})`;
            
            document.querySelectorAll('.layer-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${l}`).classList.add('active');
        }

        function clearCanvas() {
            shapes = [];
            tempShape = null;
            runDRC();
            draw();
        }
        
        function switchView(view) {
            document.getElementById('view-theory').style.opacity = view === 'theory' ? '1' : '0';
            document.getElementById('view-theory').style.pointerEvents = view === 'theory' ? 'auto' : 'none';
            document.getElementById('view-theory').style.zIndex = view === 'theory' ? '20' : '0';

            document.getElementById('view-drc').style.opacity = view === 'drc' ? '1' : '0';
            document.getElementById('view-drc').style.pointerEvents = view === 'drc' ? 'auto' : 'none';
            document.getElementById('view-drc').style.zIndex = view === 'drc' ? '20' : '0';

            document.getElementById('view-lvs').style.opacity = view === 'lvs' ? '1' : '0';
            document.getElementById('view-lvs').style.pointerEvents = view === 'lvs' ? 'auto' : 'none';
            document.getElementById('view-lvs').style.zIndex = view === 'lvs' ? '20' : '0';
            
            ['theory', 'drc', 'lvs'].forEach(t => {
                document.getElementById(`btn-${t}`).className = (t === view) ? 'tab-btn tab-active' : 'tab-btn';
            });
        }

        // Rules Slider
        const sliderNode = document.getElementById('slider-node');
        sliderNode.addEventListener('input', (e) => {
            const idx = e.target.value;
            const r = [{w:4,s:4, n:'180nm'}, {w:3,s:3, n:'90nm'}, {w:2,s:2, n:'45nm'}][idx]; // Mapping slider to rules
            currentRule = { minW: r.w, minS: r.s };
            document.getElementById('lbl-node').innerText = r.n;
            document.getElementById('rule-width').innerText = r.w + " units";
            document.getElementById('rule-space').innerText = r.s + " units";
            runDRC();
            draw();
        });

        // Init
        setLayer('metal');

    </script>
</body>
</html>
