<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-XXZS8C1FLY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-XXZS8C1FLY');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary to Gray Code Lab - EcrioniX</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&family=Orbitron:wght@500;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <!-- MathJax -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body { font-family: 'Outfit', sans-serif; background-color: #020617; color: #f8fafc; overflow: hidden; }
        .tech-font { font-family: 'Orbitron', sans-serif; }
        .mono-font { font-family: 'JetBrains Mono', monospace; }

        /* Mobile Scroll */
        @media (max-width: 1024px) { body { overflow-y: auto; } }

        .watermark {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-30deg);
            font-size: 8rem; font-weight: 900; color: rgba(99, 102, 241, 0.03);
            pointer-events: none; user-select: none; z-index: 0;
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.7); backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 20px;
        }

        /* Tabs */
        .tab-btn {
            @apply px-4 py-2 text-xs font-bold rounded-lg transition-all border border-transparent text-slate-400 uppercase tracking-wider;
        }
        .tab-active {
            @apply bg-indigo-600 text-white border-indigo-500 shadow-lg shadow-indigo-500/30;
        }

        /* Logic Visuals */
        .gate-xor { fill: #1e293b; stroke: #94a3b8; stroke-width: 2; transition: all 0.2s; }
        .gate-active { stroke: #fbbf24; filter: drop-shadow(0 0 5px #fbbf24); }
        
        .wire { fill: none; stroke: #475569; stroke-width: 2.5; stroke-linecap: round; transition: stroke 0.2s; }
        .wire-active { stroke: #fbbf24; filter: drop-shadow(0 0 3px #fbbf24); }

        .bit-box {
            width: 40px; height: 40px;
            display: flex; align-items: center; justify-content: center;
            border: 2px solid #475569; background: #0f172a;
            font-family: 'JetBrains Mono', monospace; font-weight: bold; color: #94a3b8;
            cursor: pointer; transition: all 0.2s;
        }
        .bit-active { border-color: #fbbf24; color: #fbbf24; box-shadow: 0 0 10px rgba(251, 191, 36, 0.2); }

        /* Code Block */
        pre {
            background: #0b0f19; border: 1px solid #334155; border-radius: 8px; padding: 1rem;
            font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; color: #e2e8f0;
            overflow-x: auto;
        }
        .kw { color: #c678dd; font-weight: bold; } 
        .ty { color: #e5c07b; } 
        .fn { color: #61afef; } 
        .cm { color: #7f848e; font-style: italic; } 
        .op { color: #56b6c2; }
        
        .hidden { display: none !important; }
    </style>
</head>
<body class="h-screen w-screen flex flex-col relative">

    <div class="watermark">EcrioniX Logic</div>

    <!-- Header -->
    <nav class="border-b border-slate-800 bg-slate-900/80 px-4 md:px-6 py-3 flex justify-between items-center z-50 sticky top-0 backdrop-blur-md">
        <div>
            <h1 class="text-xl md:text-2xl font-bold text-indigo-400 tech-font uppercase">GRAY <span class="text-white">CONVERTER</span></h1>
            <p class="text-[9px] md:text-[10px] text-slate-500 uppercase tracking-widest font-bold hidden md:block">Binary Coding Theory & Logic</p>
        </div>
        
        <div class="flex bg-slate-950 p-1 rounded-xl border border-slate-800">
            <button onclick="switchView('theory')" id="btn-theory" class="tab-btn tab-active">Theory</button>
            <button onclick="switchView('rtl')" id="btn-rtl" class="tab-btn">RTL Code</button>
            <button onclick="switchView('lab')" id="btn-lab" class="tab-btn">Simulation</button>
        </div>

        <button onclick="window.history.back()" class="group flex items-center text-slate-400 hover:text-white transition bg-slate-800/80 px-3 py-2 rounded-lg border border-slate-700 hover:border-indigo-500 ml-2">
            <span class="text-xs font-bold uppercase hidden md:inline">Exit Lab</span>
            <span class="text-xs font-bold uppercase md:hidden">Exit</span>
        </button>
    </nav>

    <!-- Content -->
    <div class="flex-grow relative overflow-y-auto lg:overflow-hidden">

        <!-- THEORY VIEW -->
        <div id="view-theory" class="absolute inset-0 z-10 overflow-y-auto custom-scroll p-4 md:p-8 flex justify-center">
            <div class="max-w-4xl w-full glass-panel p-6 md:p-10 prose mb-10 text-slate-300 leading-relaxed">
                <h1 class="text-3xl font-bold text-white mb-6 tech-font border-b border-slate-800 pb-2">The Magic of Gray Codes</h1>
                
                <h2 class="text-xl font-bold text-indigo-400 mt-8 mb-4 uppercase">1. What is Gray Code?</h2>
                <p>
                    Gray code, named after Frank Gray, is a binary numeral system where two successive values differ in only **one bit position**. This is fundamentally different from standard binary, where multiple bits can change simultaneously (e.g., $7 \to 8$ is `0111` $\to$ `1000`, changing 4 bits!).
                </p>

                <h2 class="text-xl font-bold text-indigo-400 mt-8 mb-4 uppercase">2. Why do we need it?</h2>
                <p>
                    The primary application of Gray code is in **glitch minimization** during signal transitions, especially in:
                </p>
                <ul class="list-disc list-inside ml-4 space-y-2 text-sm text-slate-400">
                    <li><strong>CDC (Clock Domain Crossing):</strong> In Async FIFOs, passing binary pointers between clock domains is dangerous. If a multi-bit change is sampled mid-transition, it can result in a wild, invalid value. Gray codes ensure that any sampling error only results in an off-by-one error (reading the old value or the new one), which is safe.</li>
                    <li><strong>Karnaugh Maps:</strong> K-Map axes are labeled in Gray code so that adjacent cells differ by only one variable, allowing for logical grouping.</li>
                    <li><strong>Rotary Encoders:</strong> Used in position sensors to prevent read errors.</li>
                </ul>

                <h2 class="text-xl font-bold text-indigo-400 mt-8 mb-4 uppercase">3. Conversion Logic</h2>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 my-6">
                    <div class="bg-slate-900 p-4 rounded-xl border border-slate-700">
                        <strong class="text-green-400 block mb-2">Binary to Gray</strong>
                        <p class="text-sm mb-2">To convert a binary number $B$ to Gray code $G$:</p>
                        <p class="font-mono bg-black/50 p-2 rounded text-center text-white text-lg">\[ G = B \oplus (B \gg 1) \]</p>
                        <p class="text-xs text-slate-500 mt-2">
                            The MSB is kept the same. Each subsequent bit $G[i]$ is the XOR of $B[i]$ and $B[i+1]$.
                        </p>
                    </div>

                    <div class="bg-slate-900 p-4 rounded-xl border border-slate-700">
                        <strong class="text-yellow-400 block mb-2">Gray to Binary</strong>
                        <p class="text-sm mb-2">To convert Gray code $G$ back to binary $B$:</p>
                        <p class="font-mono bg-black/50 p-2 rounded text-center text-white text-lg">\[ B[i] = G[i] \oplus B[i+1] \]</p>
                        <p class="text-xs text-slate-500 mt-2">
                            This is an iterative process. The MSB is the same. The next binary bit is the XOR of the current Gray bit and the *previous* calculated binary bit.
                        </p>
                    </div>
                </div>

                <div class="mt-8 text-center pb-8">
                    <button onclick="switchView('lab')" class="bg-indigo-600 hover:bg-indigo-500 text-white px-8 py-3 rounded-xl font-bold transition shadow-lg shadow-indigo-500/20">Start Experiment &rarr;</button>
                </div>
            </div>
        </div>

        <!-- VIEW 2: RTL CODE -->
        <div id="view-rtl" class="absolute inset-0 z-0 opacity-0 pointer-events-none overflow-y-auto custom-scroll p-4 md:p-8 flex justify-center">
            <div class="max-w-5xl w-full">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-white font-bold text-xl tech-font">SystemVerilog Implementation</h2>
                    <button class="px-3 py-1 bg-slate-800 text-slate-300 text-xs rounded border border-slate-700 hover:text-white" onclick="navigator.clipboard.writeText(document.getElementById('code-block').innerText)">Copy Code</button>
                </div>
                
<pre id="code-block">
<span class="kw">module</span> <span class="fn">bin2gray</span> #(
    <span class="kw">parameter</span> WIDTH = 4
)(
    <span class="kw">input</span>  <span class="ty">logic</span> [WIDTH-1:0] bin,
    <span class="kw">output</span> <span class="ty">logic</span> [WIDTH-1:0] gray
);
    <span class="cm">// G = B ^ (B >> 1)</span>
    <span class="kw">assign</span> gray = (bin >> 1) ^ bin;

<span class="kw">endmodule</span>

<span class="kw">module</span> <span class="fn">gray2bin</span> #(
    <span class="kw">parameter</span> WIDTH = 4
)(
    <span class="kw">input</span>  <span class="ty">logic</span> [WIDTH-1:0] gray,
    <span class="kw">output</span> <span class="ty">logic</span> [WIDTH-1:0] bin
);
    <span class="kw">always_comb</span> <span class="kw">begin</span>
        <span class="kw">for</span> (<span class="kw">int</span> i = 0; i < WIDTH; i++) <span class="kw">begin</span>
            <span class="cm">// B[i] = ^(G >> i) </span>
            <span class="cm">// XORing all bits from MSB down to i</span>
            bin[i] = ^(gray >> i);
        <span class="kw">end</span>
    <span class="kw">end</span>
<span class="kw">endmodule</span>
</pre>
            </div>
        </div>

        <!-- VIEW 3: LAB -->
        <div id="view-lab" class="absolute inset-0 z-0 opacity-0 pointer-events-none flex flex-col lg:flex-row p-4 lg:p-6 gap-6 overflow-y-auto lg:overflow-hidden">
            
            <!-- Left: Controls -->
            <div class="w-full lg:w-80 flex flex-col gap-4 flex-shrink-0">
                <div class="glass-panel p-6">
                    <h2 class="text-indigo-400 font-bold mb-4 uppercase text-[10px] tracking-widest">Configuration</h2>
                    
                    <div class="space-y-6">
                        <!-- Mode Toggle -->
                        <div>
                            <span class="text-xs text-slate-300 font-bold block mb-2">Conversion Mode</span>
                            <div class="grid grid-cols-2 gap-2">
                                <button onclick="setMode('B2G')" id="btn-b2g" class="py-2 bg-indigo-600 text-white rounded border border-indigo-500 text-xs font-bold transition shadow">Bin to Gray</button>
                                <button onclick="setMode('G2B')" id="btn-g2b" class="py-2 bg-slate-800 text-slate-400 rounded border border-slate-700 text-xs font-bold transition hover:text-white">Gray to Bin</button>
                            </div>
                        </div>

                        <!-- Bit Width -->
                        <div>
                            <div class="flex justify-between text-xs mb-2">
                                <span class="text-slate-300 font-bold">Bit Width</span>
                                <span id="val-width" class="font-mono text-white font-bold">4 Bits</span>
                            </div>
                            <input type="range" id="slider-width" min="2" max="6" step="1" value="4" class="w-full accent-indigo-500 bg-slate-800 rounded">
                        </div>

                        <!-- Input Bits -->
                        <div>
                            <span class="text-xs text-slate-300 font-bold block mb-2">Input Value</span>
                            <div id="input-bits" class="flex justify-center gap-2">
                                <!-- Generated by JS -->
                            </div>
                        </div>

                         <!-- Reset -->
                        <button onclick="resetLab()" class="w-full py-2 text-xs font-bold text-red-400 border border-red-900/30 rounded hover:bg-red-900/10">RESET</button>
                    </div>
                </div>

                <!-- Truth Table Mini -->
                <div class="glass-panel p-6 flex-grow flex flex-col overflow-hidden">
                    <h2 class="text-slate-400 font-bold mb-2 uppercase text-[10px] tracking-widest">Truth Table (3-Bit)</h2>
                    <div class="flex-grow overflow-y-auto bg-black/20 rounded border border-slate-800 text-[10px] font-mono">
                        <table class="w-full text-center">
                            <thead class="bg-slate-900 text-slate-400 sticky top-0">
                                <tr><th>Dec</th><th>Binary</th><th>Gray</th></tr>
                            </thead>
                            <tbody class="divide-y divide-slate-800 text-slate-300">
                                <tr><td>0</td><td>000</td><td>000</td></tr>
                                <tr><td>1</td><td>001</td><td>001</td></tr>
                                <tr><td>2</td><td>010</td><td>011</td></tr>
                                <tr><td>3</td><td>011</td><td>010</td></tr>
                                <tr><td>4</td><td>100</td><td>110</td></tr>
                                <tr><td>5</td><td>101</td><td>111</td></tr>
                                <tr><td>6</td><td>110</td><td>101</td></tr>
                                <tr><td>7</td><td>111</td><td>100</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Right: Visualization -->
            <div class="flex-grow glass-panel relative flex flex-col p-1 overflow-hidden bg-slate-900/50 min-h-[400px]">
                <div class="absolute top-4 left-4 z-10 px-3 py-1 bg-black/60 rounded text-[10px] text-slate-400 border border-slate-700 font-bold uppercase tracking-widest">
                    Logic Gate Visualizer
                </div>
                
                <div class="flex-grow flex items-center justify-center relative overflow-x-auto">
                    <div class="min-w-[500px] w-full h-full flex items-center justify-center" id="schematic-container">
                        <!-- SVG Injected via JS -->
                        <svg id="main-svg" width="600" height="400" viewBox="0 0 600 400"></svg>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- State ---
        let mode = 'B2G'; // B2G or G2B
        let bitWidth = 4;
        let inputVal = 0; // Integer value
        
        // --- DOM ---
        const svg = document.getElementById('main-svg');
        const inputContainer = document.getElementById('input-bits');
        const sWidth = document.getElementById('slider-width');
        const lblWidth = document.getElementById('val-width');

        // --- View Logic ---
        function switchView(v) {
            const views = ['theory', 'rtl', 'lab'];
            views.forEach(id => {
                const el = document.getElementById(`view-${id}`);
                const btn = document.getElementById(`btn-${id}`);
                if (id === v) {
                    el.classList.remove('opacity-0', 'pointer-events-none'); el.classList.add('z-10');
                    btn.classList.add('tab-active');
                } else {
                    el.classList.add('opacity-0', 'pointer-events-none'); el.classList.remove('z-10');
                    btn.classList.remove('tab-active');
                }
            });
            if (v === 'lab') {
                updateUI();
            }
        }

        function setMode(m) {
            mode = m;
            document.getElementById('btn-b2g').className = m==='B2G' ? "flex-1 py-2 bg-indigo-600 text-white rounded border border-indigo-500 text-xs font-bold transition shadow" : "flex-1 py-2 bg-slate-800 text-slate-400 rounded border border-slate-700 text-xs font-bold transition hover:text-white";
            document.getElementById('btn-g2b').className = m==='G2B' ? "flex-1 py-2 bg-indigo-600 text-white rounded border border-indigo-500 text-xs font-bold transition shadow" : "flex-1 py-2 bg-slate-800 text-slate-400 rounded border border-slate-700 text-xs font-bold transition hover:text-white";
            drawSchematic();
        }

        sWidth.addEventListener('input', (e) => {
            bitWidth = parseInt(e.target.value);
            lblWidth.innerText = bitWidth + " Bits";
            inputVal = 0; // Reset value on width change
            updateUI();
            drawSchematic();
        });

        function toggleBit(idx) {
            // Flip bit at idx (0 is LSB)
            // Visual index is Left to Right (MSB to LSB).
            // data array: [MSB ... LSB]
            // We store integer.
            
            // Re-calculate based on visual index from left (0 to width-1)
            // Bit position in integer: (width - 1 - idx)
            const bitPos = bitWidth - 1 - idx;
            inputVal ^= (1 << bitPos);
            updateUI();
            drawSchematic(); // Update wire states
        }

        function resetLab() {
            inputVal = 0;
            updateUI();
            drawSchematic();
        }

        function updateUI() {
            inputContainer.innerHTML = '';
            for(let i=0; i<bitWidth; i++) {
                const bitPos = bitWidth - 1 - i;
                const bit = (inputVal >> bitPos) & 1;
                
                const btn = document.createElement('div');
                btn.className = `bit-box ${bit ? 'bit-active' : ''}`;
                btn.innerText = bit;
                btn.onclick = () => toggleBit(i);
                inputContainer.appendChild(btn);
            }
        }

        // --- Schematic Rendering ---
        function drawSchematic() {
            // Clear
            let svgContent = `<defs>
                <g id="xor-gate">
                    <path d="M0,0 Q10,20 0,40 L10,40 Q40,20 10,0 H0 M-3,0 Q7,20 -3,40" class="gate-xor" />
                    <line x1="-3" y1="10" x2="0" y2="10" stroke="#94a3b8" />
                    <line x1="-3" y1="30" x2="0" y2="30" stroke="#94a3b8" />
                </g>
                <marker id="arrow" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto"><path d="M0,0 L0,6 L6,3 z" fill="#475569" /></marker>
            </defs>`;

            const inputBits = [];
            for(let i=0; i<bitWidth; i++) inputBits.push((inputVal >> (bitWidth-1-i)) & 1);

            const startX = 50;
            const gapY = 60;
            const startY = 50;
            
            // Calculate Outputs based on mode
            let outputBits = [];
            if (mode === 'B2G') {
                // G[i] = B[i] ^ B[i+1]
                // MSB is same
                outputBits[0] = inputBits[0];
                for(let i=1; i<bitWidth; i++) {
                    outputBits[i] = inputBits[i-1] ^ inputBits[i];
                }
            } else {
                // G2B: B[i] = G[i] ^ B[i-1] (Cumulative XOR)
                let temp = inputBits[0];
                outputBits[0] = temp;
                for(let i=1; i<bitWidth; i++) {
                    temp = temp ^ inputBits[i];
                    outputBits[i] = temp;
                }
            }

            // Draw Inputs
            inputBits.forEach((bit, i) => {
                const y = startY + i*gapY;
                svgContent += `<text x="${startX}" y="${y+5}" fill="${bit?'#fbbf24':'#475569'}" font-weight="bold" font-family="monospace">${bit}</text>`;
                svgContent += `<text x="${startX-30}" y="${y+5}" fill="#64748b" font-size="10">${mode==='B2G'?'B':'G'}${bitWidth-1-i}</text>`;
                
                // Input Wire Start
                svgContent += `<line x1="${startX+15}" y1="${y}" x2="${startX+50}" y2="${y}" class="wire ${bit?'wire-active':''}" />`;
            });

            // Draw Logic & Gates
            if (mode === 'B2G') {
                // MSB Pass through
                svgContent += `<line x1="${startX+50}" y1="${startY}" x2="${startX+300}" y2="${startY}" class="wire ${inputBits[0]?'wire-active':''}" marker-end="url(#arrow)" />`;
                
                // XOR Gates
                for(let i=1; i<bitWidth; i++) {
                    const y = startY + i*gapY;
                    const prevY = startY + (i-1)*gapY;
                    
                    // Tap from previous input
                    svgContent += `<path d="M${startX+50},${prevY} V${y-15} H${startX+150}" class="wire ${inputBits[i-1]?'wire-active':''}" fill="none" />`;
                    svgContent += `<circle cx="${startX+50}" cy="${prevY}" r="3" fill="${inputBits[i-1]?'#fbbf24':'#475569'}" />`;

                    // Current input
                    svgContent += `<line x1="${startX+50}" y1="${y}" x2="${startX+150}" y2="${y+5}" class="wire ${inputBits[i]?'wire-active':''}" />`; // To XOR Input B

                    // Gate
                    const gateY = y - 25;
                    const isActive = outputBits[i];
                    svgContent += `<use href="#xor-gate" x="${startX+150}" y="${gateY}" class="${isActive?'gate-active':''}" />`;
                    
                    // Output Wire
                    svgContent += `<line x1="${startX+200}" y1="${y-5}" x2="${startX+300}" y2="${y-5}" class="wire ${isActive?'wire-active':''}" marker-end="url(#arrow)" />`;
                }
            } 
            else {
                // Gray to Binary (Cascading XOR)
                // MSB Pass
                svgContent += `<line x1="${startX+50}" y1="${startY}" x2="${startX+300}" y2="${startY}" class="wire ${outputBits[0]?'wire-active':''}" marker-end="url(#arrow)" />`;
                
                // Gates
                for(let i=1; i<bitWidth; i++) {
                    const y = startY + i*gapY;
                    const prevY = startY + (i-1)*gapY; // Visual Y of previous OUTPUT row
                    // In G2B, feedback comes from previous OUTPUT bit
                    
                    // Note: Cascading layout is tricky visually to prevent overlap.
                    // Staggering x positions is best.
                    const gateX = startX + 100 + (i*50); 
                    
                    // Input Wire (G bit)
                    svgContent += `<line x1="${startX+50}" y1="${y}" x2="${gateX}" y2="${y+5}" class="wire ${inputBits[i]?'wire-active':''}" />`;
                    
                    // Feedback Wire from Previous Output (Calculated bit B[i-1])
                    // Need to tap from the output line of the previous stage
                    // Previous output Y approx?
                    // Let's assume output wires run horizontally at y-5
                    
                    // Correct logic: Input A of XOR comes from Output of Previous XOR
                    let tapX = startX + 100 + ((i-1)*50) + 50; // Output of prev gate
                    if (i===1) tapX = startX + 80; // MSB wire tap

                    let tapY = (i===1) ? startY : (startY + (i-1)*gapY - 5);
                    
                    svgContent += `<path d="M${tapX},${tapY} V${y-15} H${gateX}" class="wire ${outputBits[i-1]?'wire-active':''}" fill="none" />`;
                    svgContent += `<circle cx="${tapX}" cy="${tapY}" r="3" fill="${outputBits[i-1]?'#fbbf24':'#475569'}" />`;

                    // Gate
                    const gateY = y - 25;
                    const isActive = outputBits[i];
                    svgContent += `<use href="#xor-gate" x="${gateX}" y="${gateY}" class="${isActive?'gate-active':''}" />`;

                    // Output Line
                    svgContent += `<line x1="${gateX+50}" y1="${y-5}" x2="${startX+300}" y2="${y-5}" class="wire ${isActive?'wire-active':''}" marker-end="url(#arrow)" />`;
                }
            }

            // Draw Outputs
            outputBits.forEach((bit, i) => {
                const y = startY + i*gapY;
                // Output Value
                svgContent += `<text x="${startX+320}" y="${y+5}" fill="${bit?'#fbbf24':'#475569'}" font-weight="bold" font-family="monospace" font-size="14">${bit}</text>`;
                // Label
                svgContent += `<text x="${startX+350}" y="${y+5}" fill="#64748b" font-size="10">${mode==='B2G'?'G':'B'}${bitWidth-1-i}</text>`;
            });

            svg.innerHTML = svgContent;
        }

        // Init
        updateUI();
        drawSchematic();
        switchView('theory');

    </script>
</body>
</html>
