<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-XXZS8C1FLY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-XXZS8C1FLY');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karnaugh Map Simplification - EcrioniX Labs</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&family=Orbitron:wght@500;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <!-- MathJax -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body { font-family: 'Outfit', sans-serif; background-color: #020617; color: #f8fafc; overflow: hidden; }
        .tech-font { font-family: 'Orbitron', sans-serif; }
        .mono-font { font-family: 'JetBrains Mono', monospace; }

        /* Mobile Scrolling */
        @media (max-width: 1024px) { body { overflow-y: auto; } }

        .watermark {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-30deg);
            font-size: 8rem; font-weight: 900; color: rgba(99, 102, 241, 0.03);
            pointer-events: none; user-select: none; z-index: 0;
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.7); backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 20px;
        }

        /* Tabs */
        .tab-btn {
            @apply px-4 py-2 text-xs font-bold rounded-lg transition-all border border-transparent text-slate-400 uppercase tracking-wider;
        }
        .tab-active {
            @apply bg-indigo-600 text-white border-indigo-500 shadow-lg shadow-indigo-500/30;
        }

        /* K-Map Grid */
        .kmap-cell {
            @apply relative flex items-center justify-center font-bold text-lg cursor-pointer transition-colors select-none;
            border: 1px solid #334155;
            background: #0f172a;
        }
        .kmap-cell:hover { background: #1e293b; }
        .val-1 { color: #4ade80; }
        .val-0 { color: #94a3b8; opacity: 0.5; }
        .val-x { color: #facc15; }

        /* Grouping Rectangles (SVG Overlay) */
        .group-rect {
            fill: none; stroke-width: 3; stroke-linecap: round; stroke-linejoin: round;
            opacity: 0.8; animation: dash 1s linear infinite;
        }
        @keyframes dash { to { stroke-dashoffset: 20; } }

        /* Theory Styles */
        .prose h1 { @apply text-3xl font-bold text-white mb-6 tech-font border-b border-slate-800 pb-2; }
        .prose h2 { @apply text-xl font-bold text-indigo-400 mt-8 mb-4 uppercase tracking-wider; }
        .prose h3 { @apply text-lg font-bold text-emerald-400 mt-6 mb-2; }
        .prose p { @apply text-slate-400 mb-4 leading-relaxed; }
        .prose strong { @apply text-white font-semibold; }
        .prose ul { @apply list-disc list-inside space-y-2 text-slate-400 mb-4; }
        .prose code { @apply bg-slate-900 px-1 py-0.5 rounded text-yellow-300 font-mono text-sm; }

        .hidden { display: none !important; }
    </style>
</head>
<body class="h-screen w-screen flex flex-col relative">

    <div class="watermark">EcrioniX Logic</div>

    <!-- Header -->
    <nav class="border-b border-slate-800 bg-slate-900/80 px-4 md:px-6 py-3 md:py-4 flex justify-between items-center z-20 sticky top-0 backdrop-blur-md">
        <div>
            <h1 class="text-xl md:text-2xl font-bold text-indigo-400 tech-font uppercase">K-MAP <span class="text-white">SOLVER</span></h1>
            <p class="text-[9px] md:text-[10px] text-slate-500 uppercase tracking-widest font-bold hidden md:block">Boolean Logic Simplification</p>
        </div>
        
        <div class="flex bg-slate-950 p-1 rounded-xl border border-slate-800">
            <button onclick="switchView('theory')" id="btn-theory" class="tab-btn tab-active">Theory</button>
            <button onclick="switchView('lab')" id="btn-lab" class="tab-btn">Lab</button>
        </div>

        <button onclick="window.history.back()" class="group flex items-center text-slate-400 hover:text-white transition bg-slate-800/80 px-3 py-2 rounded-lg border border-slate-700 hover:border-indigo-500 ml-2">
            <span class="text-xs font-bold uppercase hidden md:inline">Exit Lab</span>
            <span class="text-xs font-bold uppercase md:hidden">Exit</span>
        </button>
    </nav>

    <!-- Content -->
    <div class="flex-grow relative overflow-y-auto lg:overflow-hidden">

        <!-- THEORY VIEW -->
        <div id="view-theory" class="absolute inset-0 z-10 overflow-y-auto custom-scroll p-4 md:p-8 flex justify-center">
            <div class="max-w-4xl w-full glass-panel p-6 md:p-10 prose mb-10">
                <h1>Mastering the Karnaugh Map</h1>
                <p>
                    The <strong>Karnaugh Map (K-Map)</strong> is a graphical tool used to simplify Boolean algebra expressions. Invented by Maurice Karnaugh in 1953, it transforms the complex task of algebraic reduction into a visual pattern-matching game. By organizing truth table data into a special grid layout, logic redundancies become immediately obvious as geometric clusters.
                </p>

                <h2>1. The Power of Gray Codes</h2>
                <p>
                    The magic of the K-Map lies in its coordinate system. Unlike a standard binary sequence (00, 01, 10, 11), K-Maps order their rows and columns using <strong>Gray Code</strong> (00, 01, 11, 10).
                </p>
                <div class="bg-indigo-500/10 border-l-4 border-indigo-500 p-4 my-4">
                    <p class="text-slate-300 italic">
                        <strong>Why?</strong> In Gray Code, adjacent cells differ by exactly one bit. This "Adjacency Property" means that if two neighboring cells both output '1', the variable that changes between them is irrelevant (redundant) and can be eliminated.
                    </p>
                </div>

                <h2>2. Grouping Rules</h2>
                <p>Simplification is done by grouping 1s into rectangles. The rules are strict:</p>
                <ul>
                    <li><strong>Power of 2:</strong> Groups must contain $1, 2, 4, 8, 16 \dots$ cells. You cannot group 3 or 6.</li>
                    <li><strong>Orthogonal:</strong> Groups can be horizontal or vertical, but never diagonal.</li>
                    <li><strong>Wrapping:</strong> The map is toroidal. The top edge wraps to the bottom, and the left edge wraps to the right. A group can span across these boundaries.</li>
                    <li><strong>Maximize:</strong> Always form the largest possible groups. A group of 4 is better than two groups of 2.</li>
                    <li><strong>Overlap:</strong> Groups can overlap. This helps create larger (and thus simpler) groups.</li>
                </ul>

                <h2>3. Map Structures</h2>
                
                <h3>3-Variable Map (Variables A, B, C)</h3>
                <p>
                    This is a $2 \times 4$ grid (8 cells).
                    <br>Rows: A (0, 1)
                    <br>Cols: BC (00, 01, 11, 10)
                    <br>Example: A group covering the entire top row eliminates B and C, leaving just \( A' \).
                </p>

                <h3>4-Variable Map (Variables A, B, C, D)</h3>
                <p>
                    This is a $4 \times 4$ grid (16 cells).
                    <br>Rows: AB (00, 01, 11, 10)
                    <br>Cols: CD (00, 01, 11, 10)
                    <br>A group of 16 (the whole map) simplifies to Logic 1. A single cell implies a minterm with all 4 literals (e.g., \( ABCD \)).
                </p>

                <h2>4. Implicants & Essentials</h2>
                <p>
                    <strong>Implicant:</strong> Any valid group of 1s.<br>
                    <strong>Prime Implicant (PI):</strong> A group that cannot be made any larger.<br>
                    <strong>Essential Prime Implicant (EPI):</strong> A Prime Implicant that covers at least one '1' that no other PI covers. EPIs <em>must</em> be included in the final solution.
                </p>

                <h2>5. Don't Cares (X)</h2>
                <p>
                    In digital logic, some input combinations may never occur (e.g., in BCD encoding, inputs 1010-1111 are invalid). We mark these outputs as <strong>'X'</strong>.
                </p>
                <p>
                    <strong>Strategy:</strong> Treat 'X' as a '1' if it helps you form a larger group. Treat it as a '0' if it doesn't. This flexibility drastically simplifies logic circuits.
                </p>

                <div class="mt-8 text-center pb-8">
                    <button onclick="switchView('lab')" class="bg-indigo-600 hover:bg-indigo-500 text-white px-8 py-3 rounded-xl font-bold transition shadow-lg shadow-indigo-500/20">Launch Solver &rarr;</button>
                </div>
            </div>
        </div>

        <!-- LAB VIEW -->
        <div id="view-lab" class="absolute inset-0 z-0 opacity-0 pointer-events-none flex flex-col lg:flex-row p-4 lg:p-6 gap-6 overflow-y-auto custom-scroll">
            
            <!-- Left: Controls -->
            <div class="w-full lg:w-80 flex flex-col gap-4 flex-shrink-0">
                <div class="glass-panel p-6">
                    <h2 class="text-indigo-400 font-bold mb-4 uppercase text-[10px] tracking-widest">Map Configuration</h2>
                    
                    <div class="space-y-6">
                        <!-- Variables -->
                        <div>
                            <div class="flex justify-between text-xs mb-2">
                                <span class="text-slate-300 font-bold">Variables</span>
                                <span id="val-vars" class="font-mono text-white font-bold">3 Variables</span>
                            </div>
                            <div class="flex bg-slate-900 p-1 rounded-lg">
                                <button onclick="setVars(3)" id="btn-3var" class="flex-1 py-2 rounded text-xs font-bold bg-indigo-600 text-white shadow">3 VAR (A,B,C)</button>
                                <button onclick="setVars(4)" id="btn-4var" class="flex-1 py-2 rounded text-xs font-bold bg-slate-800 text-slate-400 hover:text-white">4 VAR (A..D)</button>
                            </div>
                        </div>

                        <!-- Reset -->
                        <button onclick="resetMap()" class="w-full py-2 bg-red-900/30 text-red-400 border border-red-800 rounded text-xs font-bold hover:bg-red-900/50">RESET GRID</button>

                        <div class="bg-slate-900/50 border border-slate-700 rounded-lg p-4">
                             <div class="text-[10px] text-slate-500 uppercase font-bold mb-2">Interaction Mode</div>
                             <div class="flex gap-2">
                                 <button onclick="setClickMode(1)" id="btn-mode-1" class="flex-1 py-2 bg-green-600/20 text-green-400 border border-green-600/50 rounded text-xs font-bold">SET 1</button>
                                 <button onclick="setClickMode(0)" id="btn-mode-0" class="flex-1 py-2 bg-slate-700 text-slate-400 border border-slate-600 rounded text-xs font-bold">SET 0</button>
                                 <button onclick="setClickMode('X')" id="btn-mode-x" class="flex-1 py-2 bg-yellow-600/20 text-yellow-400 border border-yellow-600/50 rounded text-xs font-bold">SET X</button>
                             </div>
                             <p class="text-[9px] text-slate-500 mt-2 italic">Click grid cells to toggle values.</p>
                        </div>
                    </div>
                </div>

                <!-- Equation Output -->
                <div class="glass-panel p-6 flex-grow">
                    <h2 class="text-emerald-400 font-bold mb-4 uppercase text-[10px] tracking-widest">Minimized Expression</h2>
                    <div class="bg-black/40 p-4 rounded-xl border border-slate-800 min-h-[100px] flex items-center justify-center">
                        <div id="eq-output" class="text-2xl md:text-3xl font-bold text-white font-mono tracking-wide text-center">0</div>
                    </div>
                    <div class="mt-4 text-xs text-slate-500 font-mono">
                        <p>Groups Found: <span id="group-count" class="text-white">0</span></p>
                    </div>
                </div>
            </div>

            <!-- Right: K-Map Visualization -->
            <div class="flex-grow flex flex-col gap-6 min-h-[500px] lg:min-h-0">
                <div class="glass-panel p-6 relative flex-grow overflow-hidden flex flex-col items-center justify-center bg-[#0b0f19]">
                    
                    <!-- Grid Container -->
                    <div class="relative">
                        
                        <!-- Headers -->
                        <div id="header-col" class="absolute top-[-30px] left-0 w-full flex justify-around text-xs font-mono text-indigo-400 font-bold ml-8">
                            <!-- Injected by JS -->
                        </div>
                        <div id="header-row" class="absolute top-0 left-[-40px] h-full flex flex-col justify-around text-xs font-mono text-pink-400 font-bold">
                            <!-- Injected by JS -->
                        </div>
                        
                        <!-- Axis Label -->
                        <div class="absolute -top-8 -left-8 text-xs font-bold text-slate-500 font-mono" id="axis-label">A\BC</div>

                        <!-- The Grid -->
                        <div id="kmap-grid" class="grid gap-1 bg-slate-800 border-2 border-slate-700 p-1 relative z-10">
                            <!-- Cells injected by JS -->
                        </div>

                        <!-- Grouping Overlay (SVG) -->
                        <svg id="group-overlay" class="absolute top-0 left-0 w-full h-full pointer-events-none z-20 overflow-visible" style="margin: 4px;">
                            <!-- Rects injected by JS -->
                        </svg>

                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- State ---
        let numVars = 3;
        let clickMode = 1; // 1, 0, 'X'
        let gridState = Array(16).fill(0); // Max 16 cells
        
        // Gray Codes
        const gray2 = ['00', '01', '11', '10'];
        const gray1 = ['0', '1'];
        
        // --- DOM ---
        const grid = document.getElementById('kmap-grid');
        const svg = document.getElementById('group-overlay');
        const headerCol = document.getElementById('header-col');
        const headerRow = document.getElementById('header-row');
        const axisLabel = document.getElementById('axis-label');
        const eqOutput = document.getElementById('eq-output');

        // --- View Logic ---
        function switchView(v) {
            const theory = document.getElementById('view-theory');
            const lab = document.getElementById('view-lab');
            const btnT = document.getElementById('btn-theory');
            const btnL = document.getElementById('btn-lab');

            if (v === 'theory') {
                theory.classList.remove('opacity-0', 'pointer-events-none'); theory.classList.add('z-10');
                lab.classList.add('opacity-0', 'pointer-events-none'); lab.classList.remove('z-10');
                btnT.classList.add('tab-active'); btnL.classList.remove('tab-active');
            } else {
                lab.classList.remove('opacity-0', 'pointer-events-none'); lab.classList.add('z-10');
                theory.classList.add('opacity-0', 'pointer-events-none'); theory.classList.remove('z-10');
                btnL.classList.add('tab-active'); btnT.classList.remove('tab-active');
                initMap();
            }
        }

        function setVars(n) {
            numVars = n;
            document.getElementById('btn-3var').className = n===3 ? "flex-1 py-2 rounded text-xs font-bold bg-indigo-600 text-white shadow" : "flex-1 py-2 rounded text-xs font-bold bg-slate-800 text-slate-400 hover:text-white";
            document.getElementById('btn-4var').className = n===4 ? "flex-1 py-2 rounded text-xs font-bold bg-indigo-600 text-white shadow" : "flex-1 py-2 rounded text-xs font-bold bg-slate-800 text-slate-400 hover:text-white";
            document.getElementById('val-vars').innerText = n + " Variables";
            resetMap();
        }

        function setClickMode(val) {
            clickMode = val;
            const map = {1: 'btn-mode-1', 0: 'btn-mode-0', 'X': 'btn-mode-x'};
            ['btn-mode-1','btn-mode-0','btn-mode-x'].forEach(id => {
                document.getElementById(id).classList.remove('ring-2', 'ring-white');
            });
            document.getElementById(map[val]).classList.add('ring-2', 'ring-white');
        }

        function resetMap() {
            gridState.fill(0);
            initMap();
            solveMap();
        }

        function initMap() {
            grid.innerHTML = '';
            headerCol.innerHTML = '';
            headerRow.innerHTML = '';
            
            const rows = numVars === 3 ? 2 : 4;
            const cols = 4;
            const colLabels = gray2;
            const rowLabels = numVars === 3 ? gray1 : gray2;

            // Setup Grid CSS
            grid.style.gridTemplateColumns = `repeat(${cols}, 60px)`;
            grid.style.gridTemplateRows = `repeat(${rows}, 60px)`;
            
            // Adjust SVG size
            svg.style.width = (cols * 60 + 8) + 'px';
            svg.style.height = (rows * 60 + 8) + 'px'; // +padding

            axisLabel.innerText = numVars === 3 ? "A \\ BC" : "AB \\ CD";

            // Headers
            colLabels.forEach(l => headerCol.innerHTML += `<span>${l}</span>`);
            rowLabels.forEach(l => headerRow.innerHTML += `<span>${l}</span>`);

            // Cells
            // Map Indexing: 
            // 3 Var: Row A (0,1), Col BC (00,01,11,10) -> Indices: 0,1,3,2, 4,5,7,6
            // We need to map visual grid (r, c) to Gray Code index
            
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    // Gray code value for row/col
                    const gr = parseInt(rowLabels[r], 2);
                    const gc = parseInt(colLabels[c], 2);
                    
                    // Actual binary index = (row_bits << 2) | col_bits
                    // Wait, Gray code isn't the index, it's the value of vars A,B...
                    // Example 4-Var: AB (row), CD (col).
                    // Cell index = integer(ABCD)
                    
                    // Convert Gray visual pos to Binary Index
                    // Row 0 (00) -> 0. Row 1 (01) -> 1. Row 2 (11) -> 3. Row 3 (10) -> 2.
                    // This is standard K-Map ordering.
                    // We need a helper to get binary value from visual row index 0,1,2,3
                    const rBin = grayToBin(r, numVars===3 ? 1 : 2);
                    const cBin = grayToBin(c, 2);
                    
                    const cellIndex = (rBin << 2) | cBin;

                    const cell = document.createElement('div');
                    cell.className = `kmap-cell`;
                    cell.id = `cell-${cellIndex}`;
                    cell.onclick = () => toggleCell(cellIndex);
                    
                    // Render value
                    renderCellContent(cell, gridState[cellIndex]);
                    
                    // Index hint
                    const hint = document.createElement('span');
                    hint.className = "absolute top-0.5 right-1 text-[8px] text-slate-700 font-mono";
                    hint.innerText = cellIndex;
                    cell.appendChild(hint);

                    grid.appendChild(cell);
                }
            }
            solveMap();
        }

        // Helper: Visual Index (0,1,2,3) to Value (0,1,3,2) for Gray Code access
        // 1 bit: 0,1 -> 0,1
        // 2 bit: 0,1,2,3 -> 00, 01, 11, 10 -> values 0, 1, 3, 2
        function grayToBin(idx, bits) {
            if (bits === 1) return idx;
            const map = [0, 1, 3, 2];
            return map[idx];
        }

        function toggleCell(idx) {
            gridState[idx] = clickMode;
            renderCellContent(document.getElementById(`cell-${idx}`), clickMode);
            solveMap();
        }

        function renderCellContent(el, val) {
            // Keep the hint span
            const hint = el.querySelector('span');
            el.innerHTML = val;
            el.className = `kmap-cell val-${val === 'X' ? 'x' : val}`;
            if(hint) el.appendChild(hint);
        }

        // --- SOLVER ENGINE ---
        // Simplified greedy solver for demonstration
        function solveMap() {
            svg.innerHTML = '';
            let groups = [];
            let covered = new Set(); // indices covered

            // 1. Identify Minterms
            let ones = [];
            let dcs = [];
            for(let i=0; i<(numVars===3?8:16); i++) {
                if(gridState[i] === 1) ones.push(i);
                if(gridState[i] === 'X') dcs.push(i);
            }

            if (ones.length === 0) {
                eqOutput.innerText = "0";
                return;
            }
            if (ones.length + dcs.length === (numVars===3?8:16)) {
                eqOutput.innerText = "1";
                // Highlight full box
                drawGroupRect(0, 0, 4, numVars===3?2:4, '#4ade80');
                return;
            }

            // 2. Greedy Grouping Strategy
            // Try largest groups first (16, 8, 4, 2, 1)
            // Valid group sizes: 8, 4, 2, 1 (since 16 handled above)
            const sizes = [8, 4, 2, 1];
            
            // This is a complex algorithmic problem (Quine-McCluskey). 
            // For this UI demo, we will implement a simplified visual matcher.
            // We scan for valid rectangles in the grid that contain only 1s and Xs.
            
            // Helper: Check if a set of indices contains only 1s or Xs
            const isValidGroup = (indices) => {
                let hasOne = false;
                for(let idx of indices) {
                    if (gridState[idx] === 0) return false;
                    if (gridState[idx] === 1) hasOne = true;
                }
                return hasOne; // Must contain at least one real 1
            };

            // Generate potential groups based on geometry
            // A group is defined by (startRow, startCol, width, height)
            // wrapping is handled by modulo logic
            
            // Iterate all possible top-left corners
            const rows = numVars===3 ? 2 : 4;
            const cols = 4;
            
            for(let h of sizes.filter(s => s <= (numVars===3?8:16))) { // Size = number of cells
                 // Dimensions factors of size: e.g. 4 -> 1x4, 2x2, 4x1
                 const shapes = getShapes(h); // returns [{r:1, c:4}, {r:2, c:2}...]
                 
                 for(let shape of shapes) {
                     if (shape.r > rows || shape.c > cols) continue; // Can't fit logic (though wrapping exists, basic shape constraints apply)
                     
                     // Slide this shape over grid
                     for(let r=0; r<rows; r++) {
                         for(let c=0; c<cols; c++) {
                             // Check if this rectangle is valid
                             let indices = [];
                             let regionValid = true;
                             
                             for(let i=0; i<shape.r; i++) {
                                 for(let j=0; j<shape.c; j++) {
                                     // Handle wrapping
                                     const curR = (r + i) % rows;
                                     const curC = (c + j) % cols;
                                     
                                     // Convert visual (r,c) back to index
                                     const idx = (grayToBin(curR, numVars===3?1:2) << 2) | grayToBin(curC, 2);
                                     indices.push(idx);
                                     
                                     if(gridState[idx] === 0) { regionValid = false; break; }
                                 }
                                 if(!regionValid) break;
                             }
                             
                             if(regionValid) {
                                 // Check if this group covers any NEW ones
                                 let newCoverage = false;
                                 for(let idx of indices) {
                                     if(gridState[idx] === 1 && !covered.has(idx)) newCoverage = true;
                                 }
                                 
                                 if (newCoverage) {
                                     // Add Group
                                     groups.push({indices, r, c, w: shape.c, h: shape.r});
                                     indices.forEach(idx => { if(gridState[idx] === 1) covered.add(idx); });
                                     
                                     // Draw
                                     const color = ['#f87171', '#60a5fa', '#facc15', '#4ade80'][groups.length % 4];
                                     drawGroupRect(c, r, shape.c, shape.r, color);
                                 }
                             }
                         }
                     }
                 }
            }
            
            document.getElementById('group-count').innerText = groups.length;
            
            // 3. Generate Expression
            let terms = groups.map(g => termFromGroup(g.indices));
            eqOutput.innerHTML = terms.join(" + ") || "0";
        }

        function getShapes(n) {
            let s = [];
            // Powers of 2 only
            if(n===8) s = [{r:2,c:4}, {r:4,c:2}]; // 3var only has 2 rows max
            if(n===4) s = [{r:1,c:4}, {r:2,c:2}, {r:4,c:1}];
            if(n===2) s = [{r:1,c:2}, {r:2,c:1}];
            if(n===1) s = [{r:1,c:1}];
            return s;
        }

        function drawGroupRect(c, r, w, h, color) {
            // Handling wrapping visually is hard with one rect. 
            // If c+w > 4, it wraps horizontally.
            // If r+h > rows, it wraps vertically.
            
            const cellW = 60;
            const padding = 4;
            
            // Simplified: Just draw non-wrapped part or full box if fits
            // Accurate drawing requires multiple rects for wrapped groups
            
            // Top Left visual coord
            const x = c * cellW + padding;
            const y = r * cellW + padding;
            const width = w * cellW - (padding*2);
            const height = h * cellW - (padding*2);
            
            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.setAttribute("x", x);
            rect.setAttribute("y", y);
            rect.setAttribute("width", width);
            rect.setAttribute("height", height);
            rect.setAttribute("rx", 10);
            rect.setAttribute("class", "group-rect");
            rect.style.stroke = color;
            
            svg.appendChild(rect);
        }

        function termFromGroup(indices) {
            // Find bits that don't change
            // indices is array of integers.
            // Check bits 3,2,1,0
            
            const first = indices[0];
            let mask = 0; // Bits that change
            
            indices.forEach(idx => {
                mask |= (first ^ idx);
            });
            
            // If mask bit i is 0, then bit i is constant
            let term = "";
            const vars = ['D','C','B','A']; // LSB is A? No usually A is MSB.
            // 4 var: AB (rows), CD (cols). Index bits: 3(A), 2(B), 1(C), 0(D).
            // Let's assume A=8, B=4, C=2, D=1.
            
            const varNames = numVars === 3 ? ['A','B','C'] : ['A','B','C','D'];
            const bitCount = numVars;
            
            for(let b=bitCount-1; b>=0; b--) {
                const bitVal = (first >> b) & 1;
                const isConstant = !((mask >> b) & 1);
                
                if (isConstant) {
                    // Map bit index to name. 
                    // if 4 vars: b3=A, b2=B, b1=C, b0=D.
                    // if 3 vars: b2=A, b1=B, b0=C.
                    
                    // Logic to pick name:
                    // 4-var: 3->0, 2->1, 1->2, 0->3
                    const nameIdx = (bitCount - 1) - b;
                    const char = varNames[nameIdx];
                    
                    term += bitVal ? char : char + "'";
                }
            }
            return term || "1";
        }

        // Init
        setClickMode(1);
        setVars(3);

    </script>
</body>
</html>
